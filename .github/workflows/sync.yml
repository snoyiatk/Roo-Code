name: Upstream Sync

permissions:
    contents: write

on:
    schedule:
        - cron: "0 0 * * *" # every day
    # push:
    #     branches:
    #         - "main"
    workflow_dispatch:

jobs:
    sync_latest_from_upstream:
        name: Sync & merge from upstream
        runs-on: ubuntu-latest
        permissions:
          contents: write # Required for pushing tags
          actions: write # allow updates to GitHub Actions workflows

        steps:
            # Step 1: run a standard checkout action
            - name: Checkout target repo
              uses: actions/checkout@master
              with:
                  ref: main
                  fetch-depth: 0
                  token: ${{ secrets.PAT }}

            - name: 1. Get current commit hash of main branch
              id: get_prev_hash
              run: |
                echo "PREV_HASH=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
                echo "Previous main branch hash is: $(git rev-parse HEAD)"

            # Step 2: run the sync action
            - name: 2. Sync upstream changes to sync branch
              id: sync-temp
              uses: aormsby/Fork-Sync-With-Upstream-action@v3.4.1
              with:
                  upstream_sync_repo: RooCodeInc/Roo-Code
                  upstream_sync_branch: main
                  target_sync_branch: main-sync
                  target_repo_token: ${{ secrets.PAT }} # automatically generated, no need to set
                  # git_pull_args: --ff-only                       # optional arg use, defaults to simple 'pull'
                  # Set test_mode true to run tests instead of the true action!!
                  test_mode: false

            - name: 3. Find "Changeset version bump" commits
              id: find_commits
              run: |
                echo "Searching for commits between ${{ steps.get_prev_hash.outputs.PREV_HASH }} and $(git rev-parse HEAD)..."
                
                # Get the list of commit hashes that match the message in the specified range
                # The output is reversed with 'tac' so that cherry-picking happens in chronological order
                COMMIT_LIST=$(git log ${{ steps.get_prev_hash.outputs.PREV_HASH }}..HEAD --grep="Changeset version bump" --format=%H | tac)
                
                if [ -z "$COMMIT_LIST" ]; then
                  echo "No new 'Changeset version bump' commits found."
                else
                  echo "Found commits to merge:"
                  echo "$COMMIT_LIST"
                fi
                
                # Save the list to the step's output
                # We need to use a special syntax to handle multi-line output
                echo "COMMIT_LIST<<EOF" >> $GITHUB_OUTPUT
                echo "$COMMIT_LIST" >> $GITHUB_OUTPUT
                echo "EOF" >> $GITHUB_OUTPUT

            # - name: 4. Checkout target branch
            #   uses: actions/checkout@master
            #   with:
            #       ref: feat/readd-gemini-cli
            #       fetch-depth: 0

            - name: 4. Merge commits to the target branch
              env:
                GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                TARGET_BRANCH="feat/readd-gemini-cli"
                MAIN_BRANCH="main"

                # Configure git user for this action
                git config user.name "github-actions[bot]"
                git config user.email "github-actions[bot]@users.noreply.github.com"

                COMMIT_LIST="${{ steps.find_commits.outputs.COMMIT_LIST }}"
                
                git fetch origin $TARGET_BRANCH || echo "Target branch '$TARGET_BRANCH' not found on remote. It will be created."
                # Check if the branch exists on the remote.
                if git show-ref --verify --quiet "refs/remotes/origin/$TARGET_BRANCH"; then
                  echo "Checking out existing branch '$TARGET_BRANCH'..."
                  # Create a local branch that tracks the remote branch
                  git checkout -b $TARGET_BRANCH origin/$TARGET_BRANCH
                else
                  echo "Branch '$TARGET_BRANCH' does not exist on remote. Creating it from latest '$MAIN_BRANCH'."
                  # Create the branch from the current state of main (which was just synced)
                  git checkout -b $TARGET_BRANCH $MAIN_BRANCH
                fi
                # --- END OF ROBUST BRANCH CREATION/CHECKOUT ---
                  
                # Loop through each commit hash found in the previous step
                for BUMP_COMMIT_HASH in $COMMIT_LIST; do
                  echo "----------------------------------------------------"
                  echo "Processing version bump commit: $BUMP_COMMIT_HASH"
                  
                  # If the target branch doesn't exist locally yet, this is the first iteration.
                  # Create it from the parent of the first bump commit to establish a common history.
                  if ! git show-ref --verify --quiet "refs/heads/$TARGET_BRANCH"; then
                    echo "Creating '$TARGET_BRANCH' from parent of first commit..."
                    git checkout -b $TARGET_BRANCH ${BUMP_COMMIT_HASH}^
                  else
                    git checkout $TARGET_BRANCH
                  fi

                  git branch -f $MAIN_BRANCH $BUMP_COMMIT_HASH # Use -f to overwrite if it somehow exists
                  # Merge the temporary snapshot branch into our target branch
                  echo "Merging '$MAIN_BRANCH' into '$TARGET_BRANCH'..."
                  # Merge the temporary snapshot branch into our target branch
                  echo "Merging '$MAIN_BRANCH' into '$TARGET_BRANCH'..."
                  set +e
                  if ! git merge $MAIN_BRANCH --no-ff --no-edit -m "Merge snapshot at version bump ${BUMP_COMMIT_HASH}"; then
                    echo "Merge conflict detected. Attempting to resolve for 'locales' directory..."

                    # List all conflicting files
                    CONFLICTING_FILES=$(git diff --name-only --diff-filter=U)

                    # Check for conflicts outside of the 'locales' directory
                    NON_LOCALES_CONFLICTS=$(echo "$CONFLICTING_FILES" | grep -v '^locales/')

                    if [ -n "$NON_LOCALES_CONFLICTS" ]; then
                      echo "Error: Unresolvable conflicts outside of the 'locales' directory:"
                      echo "$NON_LOCALES_CONFLICTS"
                      exit 1
                    fi

                    # Resolve conflicts in the 'locales' directory by accepting "theirs"
                    LOCALE_CONFLICTS=$(echo "$CONFLICTING_FILES" | grep '^locales/')
                    if [ -n "$LOCALE_CONFLICTS" ]; then
                      echo "Resolving conflicts in 'locales' by accepting 'theirs'..."
                      for file in $LOCALE_CONFLICTS; do
                        echo "Accepting 'theirs' for $file"
                        git checkout --theirs "$file"
                        git add "$file"
                      done
                    fi

                    # Commit the resolved merge
                    git commit --no-edit
                  fi
                  set -e
                  
                  current_package_version=$(node -p "require('./src/package.json').version")
                  git tag -a "v${current_package_version}" -m "Release v${current_package_version}"
                  git push origin "$MAIN_BRANCH" "v${current_package_version}" --no-verify
                  echo "Successfully created and pushed git version v${current_package_version}"
                done

                # After the loop, push all the new merge commits at once
                echo "----------------------------------------------------"
                echo "Pushing all new merge commits to '$TARGET_BRANCH'..."
                git push origin $TARGET_BRANCH

            # - name: Merge main -> feat/readd-gemini-cli
            #   uses: devmasx/merge-branch@master
            #   with:
            #       type: now
            #       from_branch: main
            #       target_branch: feat/readd-gemini-cli
            #       github_token: ${{ secrets.GITHUB_TOKEN }}

            # Step 2: run the sync action
            # only run if previous step was successful
            - name: 5. Sync upstream changes to main branch
              if: success()
              id: sync-main
              uses: aormsby/Fork-Sync-With-Upstream-action@v3.4.1
              with:
                  upstream_sync_repo: RooCodeInc/Roo-Code
                  upstream_sync_branch: main
                  target_sync_branch: main
                  target_repo_token: ${{ secrets.PAT }} # automatically generated, no need to set
                  # git_pull_args: --ff-only                       # optional arg use, defaults to simple 'pull'
                  # Set test_mode true to run tests instead of the true action!!
                  test_mode: false

    # merge-branch:
    #     runs-on: ubuntu-latest
    #     steps:
    #         - name: checkout main
    #           uses: actions/checkout@master
    #           with:
    #               ref: main

    #         - name: Merge main -> feat/readd-gemini-cli
    #           uses: devmasx/merge-branch@master
    #           with:
    #               type: now
    #               from_branch: main
    #               target_branch: feat/readd-gemini-cli
    #               github_token: ${{ secrets.GITHUB_TOKEN }}
